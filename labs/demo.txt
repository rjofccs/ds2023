sudo tshark -i br-818275ff5b0a -f "tcp and port 23" -o tcp.relative_sequence_numbers:FALSE -w /tmp.pcap -T fields -e frame.number -e tcp.seq -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.ack -e frame.time_epoch

tee /home/seed/Lab2/volumes/reset.py <<-'EOF'
#!/usr/bin/env python3
EOF

netstat -tna | grep SYN_RECV | wc -l
ss -n state syn-recv sport = :23 | wc -l
docker exec -it seed-attacker python3 /volumes/reset.py 46112 4217598685

tee /home/seed/Lab2/volumes/resetauto.py <<-'EOF'
#!/usr/bin/env python3
#!/usr/bin/python3
EOF
tee /home/seed/Lab2/volumes/synflood.py <<-'EOF'
#!/usr/bin/env python3
EOF
dmesg -Hkw

sudo insmod hello.ko
modinfo hello
lsmod | grep hello
sudo rmmod hello



unzip -d -r nf

type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
&& sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
&& echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
&& sudo apt update \
&& sudo apt install gh -y

git checkout --orphan lastest_branch&&git add -A&&git commit -am 'c'&&git branch -D main&&git branch -m main&&git push -f origin main
gh repo clone rjofccs/ms2023

https://drive.google.com/file/d/1A1IGuzwAtqnw95Y69VUC6CqK_GpIs-01/view
https://drive.google.com/file/d/1e4MIqcsDaMyreMu9-F6RnDc63cNbNs4A/view?pli=1
https://blog.csdn.net/qq_39852676/article/details/131352226














apt update && apt -y install zip python3-pip nodejs npm openjdk-17-jdk docker-compose
ln -sf /usr/bin/python3.10 /usr/bin/python
docker run -d -v /usr/local/dav:/data -p 3333:5000 sigoden/dufs /data --auth 1:1@/:rw -A
https://github.com/Snailclimb/JavaGuide
https://coder.com/docs/code-server/latest/install#debian-ubuntu
VERSION=4.14.1
USER=root
curl -fOL https://github.com/coder/code-server/releases/download/v$VERSION/code-server_${VERSION}_amd64.deb
sudo dpkg -i code-server_${VERSION}_amd64.deb
sudo systemctl enable --now code-server@$USER
# ufw disable Now visit http://0.0.0.0:5555. Your password is in
tee -i '1c bind-addr: 0.0.0.0:5555' ~/.config/code-server/config.yaml
tee -i '3c password: 5b568f7ccabd5e122a0a1911' ~/.config/code-server/config.yaml
apt install -y openjdk-17-jdk -y&&java --version

docker run -d \
  --name myubuntu \
  -e USER=root \
  -e PASSWORD=123456 \
  -e VNC_PASSWORD=123456 \
  -v /dev/shm:/dev/shm \
  -p 9999:80 \
  -p 5900:5900 \
  -e RESOLUTION=1360x768 \
  dorowu/ubuntu-desktop-lxde-vnc
https://coder.com/docs/code-server/latest/install#debian-ubuntu

https://github.com/briansjavablog/build-and-run-spring-boot-with-docker
FROM maven:3.5.2-jdk-8-alpine AS MAVEN_BUILD
MAINTAINER Brian Hannaway
COPY pom.xml /build/
COPY src /build/src/
WORKDIR /build/
RUN mvn package
FROM openjdk:8-jre-alpine
WORKDIR /app
COPY --from=MAVEN_BUILD /build/target/docker-boot-intro-0.1.0.jar /app/
ENTRYPOINT ["java", "-jar", "docker-boot-intro-0.1.0.jar"]

apt install -y libgtk3-dev
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk
window = Gdk.get_default_root_window()
x, y, width, height = window.get_geometry()
print("The size of the root window is {} x {}".format(width, height))
pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)
if pb:
    pb.savev("screenshot.png", "png", (), ())
    print("Screenshot saved to screenshot.png.")
else:
    print("Unable to get the screenshot.")


git clone https://github.com/rjofccs/webssh.git&&cd webssh&&docker-compose up -d
npm install pm2 -g&&mkdir /usr/local/pm2/
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash

https://www.bilibili.com/video/BV1KY411x7Jp/
https://blog.csdn.net/yyws2039725/article/details/111560873
https://blog.csdn.net/eric_sunah/article/details/103401311
ClientHello记录：
3. 展开ClientHello记录。(如果你的追踪包含多个ClientHello记录，展开包含第一个记录的框架)。内容类型的值是什么？
4. ClientHello记录是否包含一个nonce（也称为 "挑战"）？如果是，挑战的值是什么，用十六进制表示？
5. ClientHello记录是否公布了它所支持的网络套件？如果是，在第一个列出的套件中，公钥算法、对称密钥算法和哈希算法是什么？
ServerHello记录：
6. 找到ServerHello SSL记录。该记录是否指定了所选择的密码套件？所选择的密码套件中的算法是什么？
7. 这条记录是否包括一个nonce？如果是的话，它有多长？在SSL中，客户端和服务器端的nonce的目的是什么？
8. 这条记录是否包括一个会话ID？会话ID的目的是什么？
9. 这条记录是否包含一个证书，或者证书是否包含在一个单独的记录中。该证书是否 证书是否包含在一个以太网帧中？

客户端密钥交换记录：
10. 找到客户端密钥交换记录。该记录是否包含预主密码？这个秘密是什么 秘密用来做什么？该秘密是否被加密？如果是的话，是怎样的？加密后的秘密有多长？
更改密码规格记录（由客户发送）和加密握手记录：
11. 更改密码规格记录的目的是什么？在你的跟踪中，该记录有多少字节？
12. 在加密握手记录中，什么是被加密的？如何加密？
13. 服务器是否也向客户发送了一个变化的密码记录和一个加密的握手记录？这些记录与客户端发送的记录有什么不同？

应用数据
14. 应用数据是如何被加密的？包含应用数据的记录是否包括MAC？Wireshark是否区分了加密的应用数据和MAC?

curl -o src-cloud.zip https://seed.nyc3.cdn.digitaloceanspaces.com/src-cloud.zip&&sudo apt update&&sudo apt -y install unzip&&unzip src-cloud.zip&&cd src-cloud&&./install.sh
wget https://seedsecuritylabs.org/Labs_20.04/Files/TCP_Attacks/Labsetup.zip&&unzip Labsetup.zip&&cd Labsetup
sudo add-apt-repository -y ppa:wireshark-dev/stable
sudo apt install -y tshark
sudo tshark -i br-818275ff5b0a -f "tcp and port 23" -o tcp.relative_sequence_numbers:FALSE -w /tmp.pcap -T fields -e frame.number -e tcp.seq -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.ack -e frame.time_epoch
https://chrome.google.com/webstore/detail/awesome-chatgpt-screensho/nlipoenfbbikpbjkfpfillcgkoblgpmj?utm_source=app-launcher
https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh?utm_source=app-launcher
git clone https://github.com/rjofccs/webssh.git&&cd webssh&&docker-compose up -d
https://coder.com/docs/code-server/latest/install#debian-ubuntu
https://www.papeeria.com/p/0940d65a-981c-4726-aca2-bedabaf49ee4#/main.tex
https://raw.githubusercontent.com/rjofccs/ds2023/main/test3.png

\documentclass{article}
\usepackage{graphicx} % includegraphics command is implemented here
\begin{document}

\write18{wget http://www.some-site.com/path/to/image.png}
\includegraphics{image.png}

\end{document}


\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[margin=1.2in]{geometry}

\title{Programming Assignment - 3}
\author{Niraj J. Dedhia}
\date{March 14, 2016}

\begin{document}
\maketitle

\begin{abstract}
In this programming assignment we were supposed to understand the concepts of FFT, Inverse FFT, DCT, Inverse DCT, Hybrid Image, Cooley–Tukey algorithm and visualization. 
\end{abstract}

\section{Summary}

This assignment was divided in four parts. 1) Implementation of DFT, IDFT using Cooley Tukey algorithm , 2) Visualization part. 3) Implementation to create Hybrid Image and 4) Implementation of DCT which was for bonus marks. 

\section{Methodology}

\subsection{DFT and IDFT}
Fast Fourier Transform(FFT) algorithm computes the Discrete Fourier transform (DFT) of a sequence. FFT converts the signal from one domain to the frequency domain and IFFT converts the signal from frequency domain to the space or time domain. I have implemented Cooley Tukey algorithm for computation of FFT and IFFT for 1D and 2D. Following are the formulas for FFT1D and IFFT1D and steps for Implementation of FFT2D-IFFT2D.
$Original image = IFFT2D( FFT2D ( original image ) )$

\begin{center}
\includegraphics[width=0.9\textwidth]{fft_for.png}

$Figure 1 : FFT and IFFT Formula$
\end{center}

\begin{itemize}
\item Read an image converted it in to gray-scale and double.
\item Perform FFT for each row in Image.
\item Take transpose of Image.
\item Again perform FFT over each row in an Image (i.e. column transformation).
\item Take transpose of Image and this is the final result.
\item For inverse FFT perform the same steps the only difference is instead of FFT perform IFFT.
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{hybrid.png}

$Figure 2 : Original Image --> FFT --> IFFT$
\end{center}

\subsection{Hybrid Image}
Two images are combined in a way that resultant image after combining them looks different based on the viewing distance. Here I have taken two images 1) Dog and 2) Cat and created hybrid image (figure 2) by applying following algorithm. 
\begin{itemize}
\item Read two images converted it in to gray-scale and double.
\item Padded images with the nearest value of power of 2.
\item Defined Gaussian low pass and high pass filers of size of padded images.
\item Took DFT of Images and filters.
\item Performed element wise multiplication of first image with high pass filter and second image with low pass filter and performed(A) .
\item Subtracted the high frequency image with its original image (B).
\item Add both the images (A + B).
\item Removed the padding and displayed it.
\end{itemize}

\begin{center}
\includegraphics[width=0.6\textwidth]{fft.png}

$Figure 3 : Hybrid Image$
\end{center}

\subsection{Visualization}
We were supposed to fill the stub with our implementation for showing the flaw how this FFT will turned in to IFFT, pixel by pixel visualization of conversion of FFT to IFFT. There are total six components a) Original Image, b) Log magnitude of DFFT of image, c) Used DFFT from 'b' component, d) Current component inserted in a component 'c' e) Scaled sine of component 'd', f) Inverse DFFT of Used DFFT component. Following are the steps for visualization.

\begin{itemize}
\item Read an image convert it in to gray-scale and double displayed that in first component.
\item Computed DFFT of input image and calculated the log10 of its magnitude. Then normalized it and displayed in component 2.
\item Perform the following steps iteratively for continuous visualization.
\item Searched maximum value from 'b' component(Brightest pixel value) and inserted it in component 'c' (This is also log magnitude value).
\item Took inverse DFT of de-normalized Used DFFT component. Displayed it in 'f' component.
\item For every iterations initialized the current component and scaled sine component.
\item Took the current used pixels and display it in 'd' component.
\item Computed the inverse DFFT of current component and displayed it in 'e' component. 
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{visu.png}

$Figure 4 : Visualization (After Few Iterations)$
\end{center}


\subsection{DCT and IDCT}
Discrete cosine transform(DCT) expresses a finite sequence of data points in terms of a sum of cosine functions keep changing at different frequencies. Its easy as it deals with real part only. Following are the formulas for DCT1D and IDCT1D and steps for Implementation of DCT2D-IDCT2D.
$Original image = IDCT2D( DCT2D ( original image ) )$

\begin{center}
\includegraphics[width=0.9\textwidth]{dct_for.png}

$Figure 5 : DCT and IDCT Formula$
\end{center}

\begin{itemize}
\item Read an image converted it in to gray-scale and double.
\item Perform DCT for each row in Image.
\item Take transpose of Image.
\item Again perform DCT over each row in an Image (i.e. column transformation).
\item Take transpose of Image and store it as the final result.
\item For inverse DCT perform the same steps the only difference is instead of DCT perform IDCT.
\end{itemize}

\begin{center}
\includegraphics[width=0.9\textwidth]{dct.png}

$Figure 6 : Original Image --> DCT --> IDCT$
\end{center}


\section{ References:}
$
[1] https://en.wikipedia.org/wiki/Discrete_Fourier_transform.   
\newline
[2] https://en.wikipedia.org/wiki/Hybrid_image.
\newline
[3] https://en.wikipedia.org/wiki/Discrete_cosine_transform.
\newline
[4] http://ieeexplore.ieee.org.ezproxy.rit.edu/stamp/stamp.jsp.
\newline
[5] http://www.mathworks.com/help/ .
\newline
[6] https://www.overleaf.com .
$
\end{document}

